From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mark Vainomaa <mikroskeem@mikroskeem.eu>
Date: Sat, 30 May 2020 22:48:05 +0300
Subject: [PATCH] Port Velocity's faster varint decoder - take 2


diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java b/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java
index 0ce0f1b30faebafa4875bc7e8e63844dbc056fe0..1e563dfc6c9dfeea85d3c62a7cc77d9531d7a4b5 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/Varint21FrameDecoder.java
@@ -20,6 +20,85 @@ public class Varint21FrameDecoder extends ByteToMessageDecoder
 
     @Override
     protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
+    // Firefly start - Port Velocity's faster varint decoder
+    {
+        if (!ctx.channel().isActive()) {
+            in.skipBytes(in.readableBytes());
+            return;
+        }
+
+        while (in.isReadable()) {
+            int varintEnd = in.forEachByte(reader);
+            if (varintEnd == -1) {
+                return;
+            }
+
+            if (!reader.successfulDecode) {
+                boolean tooBig = reader.read > 3;
+                reader.reset();
+                if (tooBig) {
+                    if (this.closeConnectionOnDecodeError) {
+                        ctx.channel().close();
+                    } else {
+                        throw BAD_LENGTH_CACHED;
+                    }
+                }
+                return;
+            }
+
+            if (reader.accumulated < 0) {
+                if (this.closeConnectionOnDecodeError) {
+                    ctx.channel().close();
+                } else {
+                    throw BAD_LENGTH_CACHED;
+                }
+                return;
+            }
+
+            if (reader.accumulated == 0 && !server) {
+                ctx.channel().close();
+                return;
+            }
+
+            int minimumRead = reader.read + reader.accumulated;
+            if (in.isReadable(minimumRead)) {
+                out.add(in.retainedSlice(varintEnd + 1, reader.accumulated));
+                in.skipBytes(minimumRead);
+                reader.reset();
+            } else {
+                reader.reset();
+                return;
+            }
+        }
+    }
+    private static final net.md_5.bungee.protocol.FastDecoderException BAD_LENGTH_CACHED = new net.md_5.bungee.protocol.FastDecoderException("bad frame length");
+    private final VarintByteDecoder reader = new VarintByteDecoder();
+    private static class VarintByteDecoder implements io.netty.util.ByteProcessor {
+        private int accumulated;
+        private int read;
+        private boolean successfulDecode;
+
+        @Override
+        public boolean process(byte k) {
+            accumulated |= (k & 0x7F) << read++ * 7;
+            if (read > 3) {
+                return false;
+            }
+            if ((k & 0x80) != 128) {
+                successfulDecode = true;
+                return false;
+            }
+            return true;
+        }
+
+        void reset() {
+            accumulated = 0;
+            read = 0;
+            successfulDecode = false;
+        }
+    }
+    protected void old_decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
+    // Firefly end
     {
         // Firefly start - Discard received data after closing the channel
         if (!ctx.channel().isActive()) {
